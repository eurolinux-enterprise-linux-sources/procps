From 4aff2d2a58d74a8b28d75e0d8f72bd5194106677 Mon Sep 17 00:00:00 2001
From: Qualys Security Advisory <qsa@qualys.com>
Date: Thu, 1 Jan 1970 00:00:00 +0000
Subject: [PATCH 1/3] proc/alloc.*: Use size_t, not unsigned int.

Otherwise this can truncate sizes on 64-bit platforms, and is one of the
reasons the integer overflows in file2strvec() are exploitable at all.

Warnings:

- in glibc, realloc(ptr, 0) is equivalent to free(ptr), but not here,
  because of the ++size;

We were tempted to call exit() or xerrx() in those cases, but decided
against it, because it might break things in unexpected places; TODO?
---
 proc/alloc.c | 12 ++++++------
 proc/alloc.h |  6 +++---
 2 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/proc/alloc.c b/proc/alloc.c
index 4a0aca7..71a4302 100644
--- a/proc/alloc.c
+++ b/proc/alloc.c
@@ -9,39 +9,39 @@
 #include <stdio.h>
 #include "alloc.h"
 
-void *xcalloc(void *pointer, int size) {
+void *xcalloc(void *pointer, size_t size) {
     void * ret;
     if (pointer)
         free(pointer);
     if (!(ret = calloc(1, size))) {
-        fprintf(stderr, "xcalloc: allocation error, size = %d\n", size);
+        fprintf(stderr, "xcalloc: allocation error, size = %zu\n", size);
         exit(1);
     }
     return ret;
 }
 
-void *xmalloc(unsigned int size) {
+void *xmalloc(size_t size) {
     void *p;
 
     if (size == 0)
         ++size;
     p = malloc(size);
     if (!p) {
-	fprintf(stderr, "xmalloc: malloc(%d) failed", size);
+	fprintf(stderr, "xmalloc: malloc(%zu) failed", size);
 	perror(NULL);
 	exit(1);
     }
     return(p);
 }
 
-void *xrealloc(void *oldp, unsigned int size) {
+void *xrealloc(void *oldp, size_t size) {
     void *p;
 
     if (size == 0)
         ++size;
     p = realloc(oldp, size);
     if (!p) {
-	fprintf(stderr, "xrealloc: realloc(%d) failed", size);
+	fprintf(stderr, "xrealloc: realloc(%zu) failed", size);
 	perror(NULL);
 	exit(1);
     }
diff --git a/proc/alloc.h b/proc/alloc.h
index 8c5016d..e8db09f 100644
--- a/proc/alloc.h
+++ b/proc/alloc.h
@@ -5,9 +5,9 @@
 
 EXTERN_C_BEGIN
 
-extern void *xrealloc(void *oldp, unsigned int size) MALLOC;
-extern void *xmalloc(unsigned int size) MALLOC;
-extern void *xcalloc(void *pointer, int size) MALLOC;
+extern void *xrealloc(void *oldp, size_t size) MALLOC;
+extern void *xmalloc(size_t size) MALLOC;
+extern void *xcalloc(void *pointer, size_t size) MALLOC;
 
 EXTERN_C_END
 
-- 
2.14.3


From f55e2f8c4b8b049e985bbb163db9ebdc8ca3e2e4 Mon Sep 17 00:00:00 2001
From: Qualys Security Advisory <qsa@qualys.com>
Date: Thu, 1 Jan 1970 00:00:00 +0000
Subject: [PATCH 2/3] proc/readproc.c: Harden file2str().

1/ Replace sprintf() with snprintf() (and check for truncation).

2/ Prevent an integer overflow of the return value.
---
 proc/readproc.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/proc/readproc.c b/proc/readproc.c
index c5cfc14..e8cb193 100644
--- a/proc/readproc.c
+++ b/proc/readproc.c
@@ -23,6 +23,7 @@
 #include <unistd.h>
 #include <signal.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <sys/dir.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -417,14 +418,16 @@ static void statm2proc(const char* s, proc_t *restrict P) {
 
 static int file2str(const char *directory, const char *what, char *ret, int cap) {
     static char filename[80];
-    int fd, num_read;
+    int fd, len;
+    ssize_t num_read;
 
-    sprintf(filename, "%s/%s", directory, what);
+    len = snprintf(filename, sizeof filename, "%s/%s", directory, what);
+    if (len <= 0 || (size_t)len >= sizeof filename) return -1;
     fd = open(filename, O_RDONLY, 0);
     if(unlikely(fd==-1)) return -1;
     num_read = read(fd, ret, cap - 1);
     close(fd);
-    if(unlikely(num_read<=0)) return -1;
+    if(unlikely(num_read<=0 || num_read>=INT_MAX)) return -1;
     ret[num_read] = '\0';
     return num_read;
 }
-- 
2.14.3


From 0b14b42db9c3702185d9f1118a31e80b1f07f00b Mon Sep 17 00:00:00 2001
From: Qualys Security Advisory <qsa@qualys.com>
Date: Thu, 1 Jan 1970 00:00:00 +0000
Subject: [PATCH 3/3] proc/readproc.c: Fix bugs and overflows in file2strvec().

Note: this is by far the most important and complex patch of the whole
series, please review it carefully; thank you very much!

For this patch, we decided to keep the original function's design and
skeleton, to avoid regressions and behavior changes, while fixing the
various bugs and overflows. And like the "Harden file2str()" patch, this
patch does not fail when about to overflow, but truncates instead: there
is information available about this process, so return it to the caller;
also, we used INT_MAX as a limit, but a lower limit could be used.

The easy changes:

- Replace sprintf() with snprintf() (and check for truncation).

- Replace "if (n == 0 && rbuf == 0)" with "if (n <= 0 && tot <= 0)" and
  do break instead of return: it simplifies the code (only one place to
  handle errors), and also guarantees that in the while loop either n or
  tot is > 0 (or both), even if n is reset to 0 when about to overflow.

- Remove the "if (n < 0)" block in the while loop: it is (and was) dead
  code, since we enter the while loop only if n >= 0.

- Rewrite the missing-null-terminator detection: in the original
  function, if the size of the file is a multiple of 2047, a null-
  terminator is appended even if the file is already null-terminated.

- Replace "if (n <= 0 && !end_of_file)" with "if (n < 0 || tot <= 0)":
  originally, it was equivalent to "if (n < 0)", but we added "tot <= 0"
  to handle the first break of the while loop, and to guarantee that in
  the rest of the function tot is > 0.

- Double-force ("belt and suspenders") the null-termination of rbuf:
  this is (and was) essential to the correctness of the function.

- Replace the final "while" loop with a "for" loop that behaves just
  like the preceding "for" loop: in the original function, this would
  lead to unexpected results (for example, if rbuf is |\0|A|\0|, this
  would return the array {"",NULL} but should return {"","A",NULL}; and
  if rbuf is |A|\0|B| (should never happen because rbuf should be null-
  terminated), this would make room for two pointers in ret, but would
  write three pointers to ret).

The hard changes:

- Prevent the integer overflow of tot in the while loop, but unlike
  file2str(), file2strvec() cannot let tot grow until it almost reaches
  INT_MAX, because it needs more space for the pointers: this is why we
  introduced ARG_LEN, which also guarantees that we can add "align" and
  a few sizeof(char*)s to tot without overflowing.

- Prevent the integer overflow of "tot + c + align": when INT_MAX is
  (almost) reached, we write the maximal safe amount of pointers to ret
  (ARG_LEN guarantees that there is always space for *ret = rbuf and the
  NULL terminator).
---
 proc/readproc.c | 54 +++++++++++++++++++++++++++++++++---------------------
 1 file changed, 33 insertions(+), 21 deletions(-)

diff --git a/proc/readproc.c b/proc/readproc.c
index e8cb193..e5e79b2 100644
--- a/proc/readproc.c
+++ b/proc/readproc.c
@@ -434,11 +434,12 @@ static int file2str(const char *directory, const char *what, char *ret, int cap)
 
 static char** file2strvec(const char* directory, const char* what) {
     char buf[2048];	/* read buf bytes at a time */
-    char *p, *rbuf = 0, *endbuf, **q, **ret;
+    char *p, *rbuf = 0, *endbuf, **q, **ret, *strp;
     int fd, tot = 0, n, c, end_of_file = 0;
     int align;
 
-    sprintf(buf, "%s/%s", directory, what);
+    const int len = snprintf(buf, sizeof buf, "%s/%s", directory, what);
+    if(len <= 0 || (size_t)len >= sizeof buf) return NULL;
     fd = open(buf, O_RDONLY, 0);
     if(fd==-1) return NULL;
 
@@ -446,18 +447,23 @@ static char** file2strvec(const char* directory, const char* what) {
     while ((n = read(fd, buf, sizeof buf - 1)) >= 0) {
 	if (n < (int)(sizeof buf - 1))
 	    end_of_file = 1;
-	if (n == 0 && rbuf == 0) {
-	    close(fd);
-	    return NULL;	/* process died between our open and read */
+	if (n <= 0 && tot <= 0) { /* nothing read now, nothing read before */
+	    break;		/* process died between our open and read */
 	}
-	if (n < 0) {
-	    if (rbuf)
-		free(rbuf);
-	    close(fd);
-	    return NULL;	/* read error */
+	/* ARG_LEN is our guesstimated median length of a command-line argument
+	   or environment variable (the minimum is 1, the maximum is 131072) */
+	#define ARG_LEN 64
+	if (tot >= INT_MAX / (ARG_LEN + (int)sizeof(char*)) * ARG_LEN - n) {
+	    end_of_file = 1; /* integer overflow: null-terminate and break */
+	    n = 0; /* but tot > 0 */
 	}
-	if (end_of_file && (n == 0 || buf[n-1]))/* last read char not null */
+	#undef ARG_LEN
+	if (end_of_file &&
+	    ((n > 0 && buf[n-1] != '\0') ||	/* last read char not null */
+	     (n <= 0 && rbuf[tot-1] != '\0')))	/* last read char not null */
 	    buf[n++] = '\0';			/* so append null-terminator */
+
+	if (n <= 0) break; /* unneeded (end_of_file = 1) but avoid realloc */
 	rbuf = xrealloc(rbuf, tot + n);		/* allocate more memory */
 	memcpy(rbuf + tot, buf, n);		/* copy buffer into it */
 	tot += n;				/* increment total byte ctr */
@@ -465,26 +471,32 @@ static char** file2strvec(const char* directory, const char* what) {
 	    break;
     }
     close(fd);
-    if (n <= 0 && !end_of_file) {
+    if (n < 0 || tot <= 0) {	/* error, or nothing read */
 	if (rbuf) free(rbuf);
 	return NULL;		/* read error */
     }
+    rbuf[tot-1] = '\0'; /* belt and suspenders (the while loop did it, too) */
     endbuf = rbuf + tot;			/* count space for pointers */
     align = (sizeof(char*)-1) - ((tot + sizeof(char*)-1) & (sizeof(char*)-1));
-    for (c = 0, p = rbuf; p < endbuf; p++)
-    	if (!*p)
+    c = sizeof(char*);				/* one extra for NULL term */
+    for (p = rbuf; p < endbuf; p++) {
+    	if (!*p) {
+	    if (c >= INT_MAX - (tot + (int)sizeof(char*) + align)) break;
 	    c += sizeof(char*);
-    c += sizeof(char*);				/* one extra for NULL term */
+	}
+    }
 
     rbuf = xrealloc(rbuf, tot + c + align);	/* make room for ptrs AT END */
     endbuf = rbuf + tot;			/* addr just past data buf */
     q = ret = (char**) (endbuf+align);		/* ==> free(*ret) to dealloc */
-    *q++ = p = rbuf;				/* point ptrs to the strings */
-    endbuf--;					/* do not traverse final NUL */
-    while (++p < endbuf) 
-    	if (!*p)				/* NUL char implies that */
-	    *q++ = p+1;				/* next string -> next char */
-
+    for (strp = p = rbuf; p < endbuf; p++) {
+	if (!*p) {				/* NUL char implies that */
+	    if (c < 2 * (int)sizeof(char*)) break;
+	    c -= sizeof(char*);
+	    *q++ = strp;			/* point ptrs to the strings */
+	    strp = p+1;				/* next string -> next char */
+	}
+    }
     *q = 0;					/* null ptr list terminator */
     return ret;
 }
-- 
2.14.3

